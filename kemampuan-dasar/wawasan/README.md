software engineering.

Definisi penting dari rekayasa perangkat lunak meliputi:

- "penerapan sistematis pengetahuan ilmiah dan teknologi, metode, dan pengalaman untuk desain, pelaksanaan, 
pengujian, dan dokumentasi perangkat lunak"-Biro Statistik tenaga kerja-IEEE Systems dan rekayasa perangkat lunak-Kosakata [17]
- "Penerapan pendekatan yang sistematis, disiplin, dan dapat diukur terhadap pengembangan, pengoperasian, 
dan pemeliharaan perangkat lunak" — Glosarium standar IEEE terminologi rekayasa perangkat lunak [18]
- "disiplin teknik yang berkaitan dengan semua aspek produksi perangkat lunak"-Ian Sommerville [19]
- "pendirian dan penggunaan prinsip rekayasa suara dalam rangka untuk secara ekonomi memperoleh perangkat lunak 
yang handal dan bekerja secara efisien pada mesin nyata"-Fritz Bauer [20]
- "sebuah cabang ilmu komputer yang berkaitan dengan desain, pelaksanaan, dan pemeliharaan program komputer 
yang kompleks"-Merriam-Webster [21]

Istilah ini juga telah digunakan secara kurang formal:
sebagai istilah kontemporer informal untuk berbagai kegiatan yang sebelumnya disebut pemrograman komputer dan sistem analisis; 22
sebagai istilah yang luas untuk semua aspek dari praktek pemrograman komputer, sebagai lawan dari teori pemrograman komputer, yang secara 
formal dipelajari sebagai sub-disiplin ilmu komputer; 23
sebagai istilah mewujudkan advokasi pendekatan khusus untuk pemrograman komputer, salah satu yang mendesak bahwa itu diperlakukan sebagai 
disiplin rekayasa bukan seni atau kerajinan, dan pendukung kodifikasi praktik yang direkomendasikan. 24

Bidang
- Persyaratan perangkat lunak
Persyaratan rekayasa adalah tentang mendatangkan, analisis, spesifikasi, dan validasi persyaratan untuk perangkat lunak.

- Desain perangkat lunak
Perancangan perangkat lunak adalah tentang proses penentuan arsitektur, komponen, antarmuka, dan karakteristik sistem atau 
komponen lainnya. Ini juga disebut arsitektur perangkat lunak.

- Pengembangan perangkat lunak
Pengembangan perangkat lunak, aktivitas utama konstruksi perangkat lunak: [1] [25] adalah kombinasi dari pemrograman 
(alias pengkodean), verifikasi, pengujian perangkat lunak, dan debugging. Proses pengembangan perangkat lunak: adalah definisi, implementasi, penilaian, 
pengukuran, manajemen, perubahan, dan peningkatan proses siklus hidup perangkat lunak itu sendiri. Ini sangat menggunakan m
anajemen konfigurasi perangkat lunak yaitu tentang mengendalikan perubahan secara sistematis terhadap konfigurasi, dan mempertahankan integritas dan 
kemamputelusuran dari konfigurasi dan kode di seluruh siklus hidup sistem. Proses modern menggunakan versi perangkat lunak.

- Pengujian perangkat lunak
Pengujian perangkat lunak: adalah suatu empiris, investigasi teknis yang dilakukan untuk memberikan informasi kepada para pemangku 
kepentingan mengenai kualitas produk atau layanan yang sedang diuji, dengan pendekatan yang berbeda seperti pengujian unit dan uji integrasi. 
Ini adalah salah satu aspek kualitas perangkat lunak.

- Pemeliharaan perangkat lunak
Pemeliharaan perangkat lunak: mengacu pada kegiatan yang diperlukan untuk memberikan dukungan biaya yang efektif setelah pengiriman produk perangkat lunak.


SCM - Software Configuration Management.

Dalam rekayasa perangkat lunak, manajemen konfigurasi perangkat lunak (SCM atau S/W CM) [1] adalah tugas pelacakan dan pengendalian perubahan dalam perangkat lunak, 
Bagian dari yang lebih besar lintas disiplin bidang manajemen konfigurasi. [2] praktik SCM meliputi kontrol revisi dan pembentukan garis dasar. 
Jika terjadi kesalahan, SCM dapat menentukan apa yang berubah dan siapa yang mengubahnya. Jika konfigurasi bekerja dengan baik, 
SCM dapat menentukan bagaimana untuk mereplikasi di banyak host.

Akronim "SCM" juga diperluas sebagai proses manajemen konfigurasi sumber dan perubahan perangkat lunak dan manajemen konfigurasi.
Namun, "konfigurasi" umumnya dipahami untuk menutupi perubahan yang biasanya dilakukan oleh administrator sistem.

Tujuan dari SCM umumnya:
- Identifikasi konfigurasi-mengidentifikasi konfigurasi, item konfigurasi dan garis dasar.
- Kontrol konfigurasi-menerapkan proses perubahan terkontrol. Hal ini biasanya dicapai dengan menyiapkan papan kontrol perubahan 
yang fungsi utamanya adalah untuk menyetujui atau menolak semua permintaan perubahan yang dikirim terhadap baseline apa pun.
- Akuntansi status konfigurasi-Recording dan melaporkan semua informasi yang diperlukan pada status proses pembangunan.
- Audit konfigurasi-memastikan bahwa konfigurasi berisi semua bagian yang dimaksudkan dan suara sehubungan 
dengan menentukan dokumen mereka, termasuk persyaratan, spesifikasi arsitektur dan manual pengguna.
- Membangun manajemen-mengelola proses dan peralatan yang digunakan untuk membangun.
- Manajemen proses-memastikan kepatuhan terhadap proses pengembangan organisasi.
- Manajemen lingkungan-mengelola perangkat lunak dan perangkat keras yang menjadi tuan rumah sistem.
- Teamwork-memfasilitasi interaksi tim yang terkait dengan proses.
- Pelacakan Cacat-memastikan setiap cacat memiliki ketertelusuran kembali ke sumber.
- Dengan diperkenalkannya komputasi awan tujuan alat SCM telah menjadi digabung dalam beberapa kasus. 
Alat SCM sendiri telah menjadi peralatan virtual yang dapat dipakai sebagai mesin virtual dan disimpan dengan negara dan versi. 
Alat ini dapat memodelkan dan mengelola sumber daya virtual berbasis cloud, termasuk peralatan virtual, unit penyimpanan, dan bundel perangkat lunak. 
Peran dan tanggung jawab dari para aktor telah menjadi bergabung juga dengan pengembang sekarang mampu secara dinamis instantiate virtual server dan sumber 
daya yang terkait.

Sejarah
Sejarah manajemen konfigurasi perangkat lunak (SCM) dalam komputasi dapat ditelusuri kembali sedini 1950-an, ketika CM (untuk manajemen konfigurasi), 
awalnya untuk pengembangan perangkat keras dan kontrol produksi, sedang diterapkan untuk pengembangan perangkat lunak.
Perangkat lunak awal memiliki jejak fisik, seperti kartu, kaset, dan media lainnya. Manajemen konfigurasi perangkat lunak pertama adalah operasi manual. 
Dengan kemajuan dalam bahasa dan kompleksitas, rekayasa perangkat lunak, melibatkan manajemen konfigurasi dan metode lainnya, menjadi perhatian utama 
karena masalah seperti jadwal, anggaran, dan kualitas. Pelajaran praktis, selama bertahun-tahun, telah menyebabkan definisi, dan pembentukan, prosedur dan peralatan. 
Akhirnya, alat menjadi sistem untuk mengelola perubahan perangkat lunak. [5] praktik di seluruh industri ditawarkan sebagai solusi, baik dalam cara terbuka 
atau eksklusif (seperti sistem kontrol revisi). Dengan meningkatnya penggunaan komputer, sistem muncul yang menangani lingkup yang lebih luas, 
termasuk manajemen persyaratan, desain alternatif, kontrol kualitas, dan banyak lagi; kemudian alat mengikuti pedoman organisasi, seperti model maturitas 
kemampuan Institut Teknik perangkat lunak.

Komponen manajemen konfigurasi perangkat lunak, kontrol versi, juga dikenal sebagai kontrol revisi atau kontrol sumber, [1] adalah pengelolaan perubahan pada dokumen, 
program komputer, situs web besar, dan koleksi informasi lainnya. Perubahan biasanya diidentifikasi dengan kode angka atau huruf, yang disebut "angka revisi", 
"tingkat revisi", atau hanya "revisi". Sebagai contoh, set awal file adalah "revisi 1". Ketika perubahan pertama dibuat, set yang dihasilkan adalah "revisi 2", 
dan seterusnya. Setiap revisi dikaitkan dengan stempel waktu dan orang yang membuat perubahan. Revisi dapat dibandingkan, dipulihkan, dan dengan beberapa jenis file, digabungkan.

Kebutuhan akan cara yang logis untuk mengatur dan mengontrol revisi telah ada selama hampir selama menulis telah ada, tetapi kontrol revisi menjadi jauh lebih penting, dan rumit, 
ketika era komputasi dimulai. Penomoran buku edisi dan revisi spesifikasi adalah contoh yang tanggal kembali ke era cetak saja. Hari ini, yang paling mampu (serta kompleks) 
sistem kontrol revisi adalah mereka yang digunakan dalam pengembangan perangkat lunak, di mana sebuah tim dari orang mungkin secara bersamaan membuat perubahan pada file yang sama.


Version Control 
Sistem kontrol versi (VCS) paling sering dijalankan sebagai aplikasi yang berdiri sendiri, tetapi kontrol revisi juga tertanam dalam berbagai jenis perangkat lunak
seperti pengolah kata dan spreadsheet, dokumen web kolaboratif [2] dan dalam berbagai sistem manajemen konten, misalnya Sejarah halaman Wikipedia. Kontrol revisi 
memungkinkan kemampuan untuk mengembalikan dokumen ke revisi sebelumnya, yang penting untuk memungkinkan editor untuk melacak suntingan satu sama lain, 
kesalahan yang benar, dan membela terhadap vandalisme dan spamming di wiki.

Dalam rekayasa perangkat lunak komputer, kontrol revisi adalah setiap jenis praktek yang melacak dan memberikan kontrol atas perubahan kode sumber. Pengembang perangkat lunak 
terkadang menggunakan perangkat lunak kontrol revisi untuk menyimpan file dokumentasi dan konfigurasi serta kode sumber.

Sebagai tim desain, mengembangkan dan menyebarkan perangkat lunak, itu adalah umum untuk beberapa versi dari perangkat lunak yang sama yang akan dikerahkan di 
situs yang berbeda dan untuk pengembang perangkat lunak yang akan bekerja secara bersamaan pada update. Bug atau fitur dari perangkat lunak sering hanya hadir dalam 
versi tertentu (karena memperbaiki beberapa masalah dan pengenalan orang lain sebagai program berkembang). Oleh karena itu, untuk tujuan menemukan dan memperbaiki bug, 
itu sangat penting untuk dapat mengambil dan menjalankan versi yang berbeda dari perangkat lunak untuk menentukan di mana versi (s) masalah terjadi. 
Ini juga mungkin diperlukan untuk mengembangkan dua versi perangkat lunak secara bersamaan: misalnya, di mana satu versi memiliki bug tetap, tetapi tidak ada fitur 
baru (Cabang), sementara versi lain adalah tempat fitur baru dikerjakan (trunk).
Pada tingkat yang paling sederhana, pengembang hanya dapat mempertahankan beberapa salinan dari versi yang berbeda dari program, dan label mereka dengan tepat. 
Pendekatan sederhana ini telah digunakan dalam banyak proyek perangkat lunak besar. Meskipun metode ini dapat bekerja, tidak efisien karena banyak salinan yang 
hampir identik dari program harus dipertahankan. Hal ini membutuhkan banyak disiplin diri pada bagian pengembang dan sering menyebabkan kesalahan. 
Karena kode dasar adalah sama, itu juga memerlukan izin baca-tulis-tulis-eksekusi untuk satu set pengembang, dan ini menambahkan tekanan seseorang mengelola 
izin sehingga basis kode tidak terganggu, yang menambahkan lebih kompleksitas. Akibatnya, sistem untuk mengotomatisasi beberapa atau semua proses kontrol revisi 
telah dikembangkan. Hal ini memastikan bahwa mayoritas manajemen langkah kontrol versi tersembunyi di balik layar.

Selain itu, dalam pengembangan perangkat lunak, hukum dan praktek bisnis dan lingkungan lainnya, hal itu telah menjadi semakin umum untuk satu dokumen 
atau potongan kode yang akan diedit oleh tim, anggota yang mungkin geografis tersebar dan mungkin mengejar kepentingan yang berbeda dan bahkan bertentangan. 
Kontrol revisi canggih yang melacak dan account untuk kepemilikan perubahan dokumen dan kode mungkin sangat membantu atau bahkan sangat diperlukan dalam 
situasi seperti itu.

Kontrol revisi juga dapat melacak perubahan pada file konfigurasi, seperti yang biasanya disimpan di/etc atau/usr/local/etc pada sistem Unix. 
Ini memberi administrator sistem cara lain untuk dengan mudah melacak perubahan yang dibuat dan cara untuk memutar kembali ke versi sebelumnya harus muncul.

Distributed Version Control.
Dalam pengembangan perangkat lunak, kontrol versi terdistribusi (juga dikenal sebagai kontrol revisi terdistribusi) adalah bentuk kontrol versi 
di mana basis kode lengkap, termasuk Riwayat lengkapnya, dicerminkan pada setiap komputer pengembang. [1] Hal ini memungkinkan manajemen otomatis bercabang 
dan penggabungan, mempercepat sebagian besar operasi (kecuali mendorong dan menarik), meningkatkan kemampuan untuk bekerja secara offline, dan 
tidak bergantung pada satu lokasi untuk backup. 1 2 3 4
Pada 2010, penulis pengembangan perangkat lunak Joel Spolsky menggambarkan sistem kontrol versi terdistribusi sebagai "mungkin kemajuan terbesar 
dalam teknologi pengembangan perangkat lunak dalam sepuluh tahun terakhir". 2
Sistem kontrol versi terdistribusi (DVCS) menggunakan pendekatan peer-to-peer ke kontrol versi, sebagai lawan dari pendekatan klien-server sistem terpusat. Kontrol revisi terdistribusi menyinkronkan repositori dengan mentransfer patch dari peer ke peer. 
Tidak ada versi sentral tunggal dari basis kode; sebagai gantinya, setiap pengguna memiliki copy pekerjaan dan histori perubahan penuh.

Keuntungan dari DVCS (dibandingkan dengan sistem terpusat) meliputi:

Memungkinkan pengguna untuk bekerja secara produktif ketika tidak terhubung ke jaringan.
Operasi umum (seperti commit, histori tontonan, dan perubahan yang dikembalikan) lebih cepat untuk DVCS, karena tidak perlu berkomunikasi dengan server pusat. [5] dengan DVCS, komunikasi hanya diperlukan saat berbagi perubahan di antara rekan lainnya.
Memungkinkan pekerjaan pribadi, sehingga pengguna dapat menggunakan perubahan mereka bahkan untuk draft awal mereka tidak ingin mempublikasikan. [rujukan?]
Bekerja salinan berfungsi secara efektif sebagai Remote Backup, yang menghindari mengandalkan pada satu mesin fisik sebagai titik tunggal kegagalan. 5
Memungkinkan berbagai model pengembangan yang akan digunakan, seperti menggunakan pembangunan cabang atau model komandan/Letnan. [rujukan?]
Memungkinkan kontrol terpusat dari "versi rilis" dari proyek [rujukan?]
Pada proyek perangkat lunak FOSS jauh lebih mudah untuk membuat sebuah proyek garpu dari sebuah proyek yang terhenti karena konflik kepemimpinan atau desain perselisihan.
Kekurangan DVCS (dibandingkan dengan sistem terpusat) meliputi:

Checkout awal dari repositori lebih lambat dibandingkan dengan checkout dalam sistem kontrol versi terpusat, karena semua cabang dan Riwayat revisi disalin ke mesin lokal secara default.
Kurangnya Mekanisme penguncian yang merupakan bagian dari sebagian besar VCS dan masih memainkan peran penting ketika datang ke non-mergeable file biner seperti aset grafis atau terlalu kompleks file tunggal biner atau XML paket (misalnya dokumen kantor, file PowerBI, SQL Server data Tools BI paket, dll). [rujukan?]
Penyimpanan tambahan yang diperlukan untuk setiap pengguna memiliki salinan lengkap Riwayat basis kode lengkap. 6
Peningkatan eksposur basis kode karena setiap peserta memiliki salinan lokal yang rentan. [rujukan?]
Beberapa sistem awalnya terpusat sekarang menawarkan beberapa fitur terdistribusi. Sebagai contoh, Subversion mampu melakukan banyak operasi tanpa jaringan. [7] Team Foundation Server dan Visual Studio Team Services sekarang menjadi host repositori kontrol versi terpusat dan terdistribusi melalui hosting Git.

Demikian pula, beberapa sistem terdistribusi sekarang menawarkan fitur yang mengurangi masalah waktu Checkout dan biaya penyimpanan, seperti sistem file virtual untuk Git yang dikembangkan oleh Microsoft untuk bekerja dengan basis kode yang sangat besar, [8] yang mengekspos sistem file virtual yang hanya mengunduh file ke penyimpanan lokal sesuai kebutuhan.



GIT
Git (/ɡɪt/) adalah sistem kontrol versi terdistribusi untuk melacak perubahan dalam kode sumber selama pengembangan perangkat lunak. 
Hal ini dirancang untuk mengkoordinasikan pekerjaan di antara programmer, 
tetapi dapat digunakan untuk melacak perubahan dalam setiap set file. Tujuannya adalah kecepatan, integritas data, dan dukungan 
untuk alur kerja terdistribusi, non-linear. 
Git diciptakan oleh Linus Torvalds pada 2005 untuk pengembangan kernel Linux, dengan pengembang kernel lainnya berkontribusi 
pada pengembangan awalnya. [12] pengelola-nya sekarang sejak 2005 adalah Junio Hamano. Seperti kebanyakan sistem kontrol versi terdistribusi 
lainnya, dan tidak seperti kebanyakan klien – sistem server, setiap direktori Git pada setiap komputer adalah repositori penuh dengan sejarah 
lengkap dan kemampuan pelacakan versi lengkap, terlepas dari akses jaringan atau server pusat. [13] Git adalah perangkat lunak bebas dan bersumber 
terbuka yang didistribusikan di bawah persyaratan GNU General Public License versi 2.
Pengembangan Git dimulai pada April 2005, setelah banyak pengembang kernel Linux menyerah akses ke BitKeeper, sebuah sistem manajemen sumber-kontrol (SCM) proprietary 
yang sebelumnya digunakan untuk mempertahankan proyek. pemegang hak cipta BitKeeper, Larry McVoy, telah ditarik bebas penggunaan produk setelah mengklaim bahwa Andrew 
Tridgell telah menciptakan SourcePuller oleh reverse engineering yang BitKeeper protokol. insiden yang sama juga memacu penciptaan sistem kontrol versi lain, Mercurial.

Linus Torvalds ingin sistem didistribusikan bahwa ia bisa menggunakan seperti BitKeeper, tetapi tidak ada sistem bebas yang tersedia memenuhi kebutuhannya. 
Torvalds mengutip sebuah contoh dari sistem manajemen sumber-kontrol yang membutuhkan 30 detik untuk menerapkan patch dan memperbarui semua metadata yang terkait, 
dan mencatat bahwa ini tidak akan sesuai dengan kebutuhan pengembangan kernel Linux, di mana sinkronisasi dengan pengelola sesama bisa memerlukan 250 tindakan 
tersebut sekaligus. Untuk kriteria Desain, ia menentukan bahwa patching harus mengambil tidak lebih dari tiga detik, dan menambahkan tiga poin lagi:

Ambil concurrent versi System (CVS) sebagai contoh dari apa yang tidak harus dilakukan; Jika ragu, Buatlah keputusan yang berlawanan.
Dukungan didistribusikan, BitKeeper-seperti alur kerja.
Sertakan perlindungan yang sangat kuat terhadap korupsi, baik yang tidak disengaja maupun yang jahat.
Kriteria ini menghilangkan setiap sistem kontrol versi yang masih ada, begitu segera setelah rilis pengembangan kernel Linux 2.6.12-RC2, 
Torvalds berangkat untuk menulis sendiri.
Pengembangan Git dimulai pada tanggal 3 April 2005. Torvalds mengumumkan proyek tersebut pada 6 April; menjadi hosting diri pada 7 April. 
penggabungan pertama dari beberapa cabang berlangsung pada tanggal 18 April.  Torvalds mencapai tujuan penampilannya; pada 29 April, 
yang baru lahir Git adalah pembanding rekaman patch ke pohon kernel Linux dengan laju 6,7 patch per detik. pada tanggal 16 Juni, 
Git berhasil meluncurkan kernel 2.6.12 release. 
Torvalds berbalik pemeliharaan pada 26 Juli 2005 untuk Junio Hamano, kontributor utama untuk proyek. Hamano bertanggung jawab atas rilis 
1,0 pada 21 Desember 2005 dan tetap menjadi pengelola proyek.




Memulai-tentang Version Control
Bab ini akan dimulai dengan Git. Kita akan mulai dengan menjelaskan beberapa latar belakang pada alat kontrol versi, kemudian beralih ke bagaimana untuk mendapatkan Git berjalan pada sistem Anda dan akhirnya bagaimana untuk mendapatkannya diatur untuk mulai bekerja dengan. Pada akhir bab ini Anda harus memahami mengapa Git adalah sekitar, mengapa Anda harus menggunakannya dan Anda harus siap untuk melakukannya.
Tentang Version Control
Apa itu "Version Control", dan mengapa Anda harus peduli? Kontrol versi adalah sistem yang mencatat perubahan ke berkas atau serangkaian berkas 
dari waktu ke waktu sehingga Anda dapat mengingat versi tertentu nanti. Untuk contoh dalam buku ini, Anda akan menggunakan kode sumber perangkat lunak sebagai 
file yang menjadi versi dikontrol, meskipun dalam kenyataannya Anda dapat melakukan ini dengan hampir semua jenis file pada komputer.
Jika Anda seorang desainer grafis atau web dan ingin menyimpan setiap versi gambar atau tata letak (yang pasti akan Anda inginkan), s
ebuah Version Control System (VCS) adalah hal yang sangat bijak untuk digunakan. Hal ini memungkinkan Anda untuk mengembalikan file yang dipilih 
kembali ke keadaan sebelumnya, mengembalikan seluruh proyek kembali ke keadaan sebelumnya, membandingkan perubahan dari waktu ke hari, melihat siapa yang 
terakhir diubah sesuatu yang mungkin menyebabkan masalah, yang memperkenalkan masalah dan Kapan, dan banyak lagi. Menggunakan VCS juga secara umum berarti bahwa 
jika Anda mengacaukan atau kehilangan file, Anda dapat dengan mudah memulihkan. Selain itu, Anda mendapatkan semua ini untuk overhead yang sangat sedikit.


Sistem kontrol versi lokal
Banyak orang versi-kontrol metode pilihan adalah untuk menyalin file ke direktori lain (mungkin waktu-dicap direktori, jika mereka pintar). 
Pendekatan ini sangat umum karena sangat sederhana, tetapi juga sangat rawan kesalahan. Sangat mudah untuk melupakan direktori mana Anda berada dan secara 
tidak sengaja menulis ke file yang salah atau menyalin file yang tidak Anda maksudkan.
Untuk mengatasi masalah ini, programmer lama lalu mengembangkan VCSs lokal yang memiliki database sederhana yang menyimpan semua perubahan ke file 
di bawah kontrol revisi.
Salah satu alat VCS yang paling populer adalah sistem yang disebut RCS, yang masih didistribusikan dengan banyak komputer saat ini. RCS bekerja dengan menjaga set patch (yaitu, perbedaan antara file) dalam format khusus pada disk; kemudian 
dapat kembali membuat apa file apapun tampak seperti pada setiap titik waktu dengan menambahkan semua patch.

Sistem kontrol versi terpusat
Isu utama berikutnya yang dihadapi orang adalah bahwa mereka perlu berkolaborasi dengan pengembang pada sistem lain. Untuk mengatasi masalah ini, terpusat versi kontrol sistem (CVCSs) dikembangkan. Sistem ini (seperti CVS, Subversion, dan Perforce) memiliki satu server yang berisi semua file berversi, dan sejumlah klien yang memeriksa file dari tempat pusat. Selama bertahun-tahun, ini telah menjadi standar untuk kontrol versi.
Pengaturan ini menawarkan banyak keuntungan, terutama atas VCSs lokal. Sebagai contoh, semua orang tahu derajat tertentu apa yang orang lain pada proyek lakukan. Administrator memiliki kontrol yang halus atas siapa yang dapat melakukan apa, dan itu jauh lebih mudah untuk mengelola CVCS daripada berurusan dengan database lokal pada setiap klien.

Namun, pengaturan ini juga memiliki beberapa kelemahan serius. Yang paling jelas adalah titik tunggal kegagalan yang mewakili server terpusat. Jika server itu turun selama satu jam, maka selama jam tersebut tidak ada yang dapat berkolaborasi sama sekali atau menyimpan perubahan yang diversi ke apa pun yang sedang mereka kerjakan. Jika hard disk database pusat menjadi rusak, dan backup yang tepat belum disimpan, 
Anda akan kehilangan benar segala sesuatu-seluruh sejarah proyek kecuali apa pun foto tunggal orang kebetulan memiliki pada mesin lokal mereka. Sistem VCS lokal 
menderita masalah yang sama — kapanpun Anda memiliki seluruh sejarah proyek di satu tempat, Anda berisiko kehilangan segalanya.

Sistem kontrol versi terdistribusi
Ini adalah di mana didistribusikan versi kontrol sistem (DVCSs) langkah masuk Dalam sebuah DVCS (seperti Git, Mercurial, Bazaar atau Darcs), 
klien tidak hanya memeriksa snapshot terbaru dari file; melainkan, mereka sepenuhnya mencerminkan repositori, termasuk sejarah lengkapnya. 
Jadi, jika ada server mati, dan sistem ini berkolaborasi melalui server, salah satu repositori klien dapat di
salin kembali ke server untuk mengembalikannya. Setiap klon adalah benar-benar cadangan lengkap dari semua data.
Lebih jauh lagi, banyak dari sistem ini menangani cukup baik dengan memiliki beberapa repositori jarak jauh mereka dapat bekerja dengan, 
sehingga Anda dapat berkolaborasi dengan kelompok orang yang berbeda dengan cara yang berbeda secara bersamaan dalam proyek yang sama. 
Hal ini memungkinkan Anda untuk mengatur beberapa jenis alur kerja yang tidak mungkin dalam sistem terpusat, seperti model hirarkis.




install Git 
Memulai-menginstall Git
Menginstall Git
Sebelum Anda mulai menggunakan Git, Anda harus membuatnya tersedia di komputer Anda. Bahkan jika itu sudah terinstal, itu mungkin ide yang baik untuk memperbarui ke versi terbaru. Anda dapat menginstalnya sebagai paket atau melalui installer lain, atau men-download kode sumber dan mengkompilasi sendiri.

Catatan
Buku ini ditulis menggunakan Git versi 2.8.0. Meskipun sebagian besar perintah yang kita gunakan harus bekerja bahkan dalam versi kuno Git, beberapa dari mereka mungkin tidak atau mungkin bertindak sedikit berbeda jika Anda menggunakan versi lama. Karena Git cukup baik dalam melestarikan kompatibilitas mundur, versi apapun setelah 2,8 harus bekerja dengan baik.

Instalasi di Linux
Jika Anda ingin menginstal alat Git dasar pada Linux melalui installer biner, Anda dapat melakukannya secara umum melalui alat manajemen paket yang datang dengan distribusi Anda. Jika Anda berada di Fedora (atau distribusi berbasis RPM yang terkait erat, seperti RHEL atau CentOS), Anda dapat menggunakan DNF:

$ sudo DNF menginstal Git-semua
Jika Anda menggunakan distribusi berbasis Debian, seperti Ubuntu, cobalah apt:

$ sudo apt install Git-semua
Untuk opsi lebih lanjut, ada petunjuk untuk menginstal pada beberapa distribusi Unix yang berbeda di situs Git, di https://git-scm.com/download/linux.

Memasang di macOS
Ada beberapa cara untuk menginstall Git pada sebuah Mac. Yang paling mudah adalah mungkin untuk menginstal Xcode Command Line Tools. Di Mavericks (10,9) atau di atasnya Anda dapat melakukan ini hanya dengan mencoba menjalankan git dari terminal yang pertama kalinya.

$ Git--versi
Jika Anda tidak memilikinya sudah terinstal, itu akan meminta Anda untuk menginstalnya.

Jika Anda ingin versi yang lebih up to date, Anda juga dapat menginstalnya melalui installer biner. Penginstal macOS Git dipertahankan dan tersedia untuk diunduh di situs web Git, di https://git-scm.com/download/mac.

Git macOS installer.
Gambar 7. Git macOS installer.
Anda juga dapat menginstalnya sebagai bagian dari GitHub untuk macOS install. Alat GUI Git mereka memiliki pilihan untuk menginstal alat baris perintah juga. Anda dapat mengunduh alat tersebut dari situs web GitHub untuk macOS, di https://desktop.github.com.

Instalasi pada Windows
Ada juga beberapa cara untuk menginstall Git pada Windows. Build paling resmi tersedia untuk diunduh di situs web Git. Hanya pergi ke https://git-scm.com/download/win dan download akan dimulai secara otomatis. Perhatikan bahwa ini adalah proyek yang disebut Git untuk Windows, yang terpisah dari Git sendiri; untuk informasi lebih lanjut tentang itu, pergi ke https://gitforwindows.org.

Untuk mendapatkan instalasi otomatis Anda dapat menggunakan paket Git Chocolatey. Perhatikan bahwa paket Chocolatey adalah komunitas yang dipelihara.

Cara lain yang mudah untuk mendapatkan Git diinstal adalah dengan memasang desktop GitHub. Installer termasuk versi baris perintah dari Git serta GUI. Ini juga bekerja dengan baik dengan PowerShell, dan set up solid credential caching dan waras CRLF pengaturan. Kita akan belajar lebih banyak tentang hal-hal itu sedikit kemudian, tapi Cukuplah untuk mengatakan bahwa mereka adalah hal yang Anda inginkan. Anda dapat mengunduh ini dari situs web desktop GitHub.

Menginstall dari sumber
Beberapa orang mungkin malah merasa berguna untuk menginstal Git dari sumber, karena Anda akan mendapatkan versi terbaru. Installer biner cenderung sedikit di belakang, meskipun seperti Git telah matang dalam beberapa tahun terakhir, ini telah membuat kurang dari perbedaan.

Jika Anda ingin menginstall Git dari sumber, Anda harus memiliki Library berikut yang Git tergantung pada: autotools, Curl, zlib, OpenSSL, expat, dan libiconv. Misalnya, jika Anda berada di sistem yang memiliki DNF (seperti Fedora) atau apt-get (seperti sistem berbasis Debian), Anda dapat menggunakan salah satu dari perintah ini untuk menginstal dependensi minimal untuk mengkompilasi dan menginstal Git binari:

$ sudo DNF menginstal DH-autoreconf curl-devel expat-devel gettext-devel \
  OpenSSL-devel Perl-devel zlib-devel
$ sudo apt-get install DH-autoreconf libcurl4-gnutls-dev libexpat1-dev \
  gettext libz-dev libssl-dev
Agar dapat menambahkan dokumentasi dalam berbagai format (doc, HTML, info), dependensi tambahan ini diperlukan:

$ sudo DNF menginstal asciidoc xmlto docbook2X
$ sudo apt-get install asciidoc xmlto docbook2x
Catatan
Pengguna RHEL dan RHEL-derivatif seperti CentOS dan Scientific Linux harus mengaktifkan repositori EPEL untuk men-download paket docbook2X.

Jika Anda menggunakan distribusi berbasis Debian (Debian/Ubuntu/Ubuntu-derivatif), Anda juga memerlukan paket Instal-Info:

$ sudo apt-get menginstal install-Info
Jika Anda menggunakan distribusi berbasis RPM (derivatif Fedora/RHEL/RHEL), Anda juga memerlukan paket getopt (yang sudah terinstal pada distro berbasis Debian):

$ sudo DNF menginstal getopt
Selain itu, jika Anda menggunakan Fedora/RHEL/RHEL-derivatif, Anda perlu melakukan hal ini

$ sudo ln-s/usr/bin/db2x_docbook2texi/usr/bin/docbook2x-texi
karena perbedaan nama biner.

Bila Anda memiliki semua dependensi yang diperlukan, Anda dapat pergi ke depan dan ambil tarball rilis Tagged terbaru dari beberapa tempat. 
Anda bisa mendapatkannya melalui situs kernel.org, di https://www.kernel.org/pub/so


Pengaturan dan konfigurasi akun GitHub
GitHub adalah satu host terbesar untuk repositori Git, dan merupakan titik pusat kolaborasi bagi jutaan pengembang dan proyek. Sebagian besar dari semua repositori Git dihosting di GitHub, dan banyak proyek open-source menggunakannya untuk hosting Git, pelacakan masalah, peninjauan kode, dan hal lainnya. Jadi sementara itu bukan bagian langsung dari proyek Git open source, ada kesempatan baik bahwa Anda akan ingin atau perlu untuk berinteraksi dengan GitHub di beberapa titik saat menggunakan Git secara profesional.

Bab ini adalah tentang penggunaan GitHub secara efektif. Kita akan membahas pendaftaran dan pengelolaan akun, membuat dan menggunakan repositori Git, alur kerja umum untuk berkontribusi pada proyek dan menerima kontribusi untuk Anda, antarmuka programatik GitHub dan banyak tips kecil untuk membuat hidup Anda lebih mudah secara umum.
Jika Anda tidak tertarik untuk menggunakan GitHub untuk meng-host proyek Anda sendiri atau untuk berkolaborasi dengan proyek lain yang dihosting di GitHub, Anda dapat dengan aman beralih ke Git Tools.

- Penyiapan dan konfigurasi akun
Hal pertama yang perlu Anda lakukan adalah menyiapkan akun pengguna gratis. Cukup kunjungi https://github.com, pilih nama pengguna yang belum diambil, 
berikan alamat email dan kata sandi, dan klik tombol hijau besar "sign up for GitHub".

- Akses SSH
Sampai sekarang, Anda sepenuhnya dapat terhubung dengan repositori Git menggunakan protokol https://, mengotentikasi dengan username dan password yang baru saja 
Anda Siapkan. Namun, untuk hanya mengkloning proyek publik, Anda bahkan tidak perlu mendaftar-akun yang baru kita buat datang ke dalam permainan ketika kita garpu 
proyek dan mendorong ke garpu kita sedikit kemudian.
Jika Anda ingin menggunakan remote SSH, Anda harus mengkonfigurasi Public key. (Jika Anda belum memilikinya, lihat membangkitkan SSH Public key Anda.) 
Buka pengaturan akun Anda menggunakan tautan di kanan atas jendela:

- Avatar Anda
Selanjutnya, jika Anda ingin, Anda dapat mengganti avatar yang dihasilkan untuk Anda dengan gambar yang Anda pilih. Pertama pergi ke "profil" tab 
(di atas tab kunci SSH) dan klik "upload gambar baru".
Kita akan memilih salinan logo Git yang ada pada hard drive kita dan kemudian kita mendapatkan kesempatan untuk memotongnya.
Sekarang di mana pun Anda berinteraksi di situs, orang akan melihat avatar Anda di samping nama pengguna Anda.
Jika Anda kebetulan telah meng-upload avatar untuk layanan Gravatar populer (sering digunakan untuk account Wordpress), 
bahwa avatar akan digunakan secara default dan Anda tidak perlu melakukan langkah ini.

- Alamat email Anda 
Sekarang di mana pun Anda berinteraksi di situs, orang akan melihat avatar Anda di samping nama pengguna Anda.
Jika Anda kebetulan telah meng-upload avatar untuk layanan Gravatar populer (sering digunakan untuk account Wordpress), 
bahwa avatar akan digunakan secara default dan Anda tidak perlu melakukan langkah ini.
Dalam tambahkan alamat email kita dapat melihat beberapa negara yang berbeda yang mungkin. Alamat atas diverifikasi dan ditetapkan sebagai alamat utama, yang berarti di mana Anda akan mendapatkan pemberitahuan dan tanda terima. Alamat kedua diverifikasi dan sehingga dapat diatur sebagai primer jika Anda ingin beralih mereka. Alamat terakhir tidak terverifikasi, artinya Anda tidak dapat membuat alamat utama. Jika GitHub melihat salah 
satu dari ini dalam pesan komit di repositori apapun di situs, itu akan dihubungkan dengan pengguna Anda sekarang.

- Autentikasi dua faktor
Akhirnya, untuk keamanan ekstra, Anda pasti harus mengatur otentikasi dua-faktor atau "2FA". Autentikasi dua faktor adalah mekanisme 
autentikasi yang menjadi semakin populer belakangan ini untuk mengurangi risiko akun Anda dikompromikan jika kata sandi Anda dicuri entah bagaimana. 
Mengubahnya akan membuat GitHub meminta Anda untuk dua metode otentikasi yang berbeda, 
sehingga jika salah satu dari mereka terganggu, penyerang tidak akan dapat mengakses akun Anda.
Anda dapat menemukan pengaturan autentikasi dua faktor di bawah tab Keamanan di setelan akun.
Jika Anda klik pada "mengatur dua faktor otentikasi" tombol, akan membawa Anda ke halaman konfigurasi di mana Anda dapat memilih untuk menggunakan 
aplikasi telepon untuk menghasilkan kode sekunder Anda ("waktu berdasarkan satu kali password"), atau Anda dapat memiliki GitHub mengirimkan kode 
melalui SMS setiap kali Anda Ne untuk masuk.
Setelah Anda memilih metode yang Anda inginkan dan ikuti petunjuk untuk menyiapkan 2FA, akun Anda kemudian akan sedikit lebih aman dan 
Anda harus memberikan kode selain kata sandi Anda setiap kali Anda masuk ke GitHub.


Membuat repositori baru
Anda dapat membuat repositori baru pada akun pribadi Anda atau organisasi mana pun Anda memiliki izin yang memadai.
1. Di sudut kanan atas halaman mana pun, gunakan menu drop-down, lalu pilih repositori baru.
2. Secara opsional, untuk membuat repositori dengan struktur direktori dan file dari repositori yang ada, gunakan drop-down choose template dan 
pilih repositori template. Anda akan melihat repositori template yang dimiliki oleh Anda dan organisasi tempat Anda menjadi anggota atau yang 
telah Anda gunakan sebelumnya. Untuk informasi lebih lanjut, lihat "Creating a repository from a template."
3. Gunakan menu drop-down pemilik, dan pilih akun yang Anda inginkan untuk memiliki repositori.
4. Ketik nama untuk repositori Anda, dan deskripsi opsional.
5. Pilih visibilitas repositori. Untuk informasi lebih lanjut, lihat "About repository visibility."
6. Jika Anda tidak menggunakan template, ada sejumlah item opsional yang dapat Anda isi sebelumnya dari repositori Anda. Jika Anda mengimpor 
repositori yang sudah ada ke GitHub, jangan memilih opsi ini, karena Anda dapat memperkenalkan konflik penggabungan. Anda dapat menambahkan 
atau membuat file baru menggunakan antarmuka pengguna atau memilih untuk menambahkan file baru menggunakan baris perintah nanti. Untuk informasi lebih lanjut, lihat
"Importing a Git repository using the command line," "Adding a file to a repository using the command line," dan "Addressing merge conflicts."
- Anda dapat membuat README, yang merupakan dokumen yang menjelaskan proyek Anda. Untuk informasi lebih lanjut, lihat "About READMEs."
- Anda dapat membuat berkas. gitignore, yang merupakan sekumpulan aturan abaikan. Untuk informasi lebih lanjut, lihat "Ignoring files."
- Anda dapat memilih untuk menambahkan lisensi perangkat lunak untuk proyek Anda. Untuk informasi lebih lanjut, lihat "Licensing a repository."
7. Opsional, jika akun atau organisasi pribadi tempat Anda membuat menggunakan aplikasi GitHub dari GitHub Marketplace, pilih aplikasi apa pun yang ingin Anda gunakan dalam repositori.
8. Klik Create repository.
9. Di bagian bawah halaman penyiapan cepat yang dihasilkan, di bawah "Import code from an old repository", Anda dapat memilih untuk mengimpor 
proyek ke repositori baru Anda. Untuk melakukannya, klik Import code.